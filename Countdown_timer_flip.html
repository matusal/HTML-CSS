<div class="flip-countdown"></div>

<style>
    body {}

    @-webkit-keyframes last_rotate {
        0% {
            -webkit-transform: rotateX(0deg);
            transform: rotateX(0deg);
            z-index: 1;
        }

        100% {
            -webkit-transform: rotateX(-180deg);
            transform: rotateX(-180deg);
            z-index: 0;
        }
    }

    @keyframes last_rotate {
        0% {
            -webkit-transform: rotateX(0deg);
            transform: rotateX(0deg);
            z-index: 1;
        }

        100% {
            -webkit-transform: rotateX(-180deg);
            transform: rotateX(-180deg);
            z-index: 0;
        }
    }

    @-webkit-keyframes new_rotate {
        0% {
            -webkit-transform: rotateX(0deg);
            transform: rotateX(0deg);
            z-index: 0;
        }

        100% {
            -webkit-transform: rotateX(-180deg);
            transform: rotateX(-180deg);
            z-index: 1;
        }
    }

    @keyframes new_rotate {
        0% {
            -webkit-transform: rotateX(0deg);
            transform: rotateX(0deg);
            z-index: 0;
        }

        100% {
            -webkit-transform: rotateX(-180deg);
            transform: rotateX(-180deg);
            z-index: 1;
        }
    }

    .flip-countdown {
        display: flex;
        justify-content: center;
        font-family: "Roboto", sans-serif;
        font-size: 4.1em;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        overflow: hidden;


        text-align: center;
        margin: 50px;
        display: flex;
        justify-content: center;
        align-items: center;
        align-items: center;

        background-image: url(https://custom.cvent.com/851C36FCAE944E17AB465BD57AFEB1E0/pix/279f55c730c748019e8441d09474008e.jpg);

        background-size: 700px;
        background-repeat: no-repeat;
        background-position: center center;
        height: 210px;
        padding-left: 8px;
        padding-top: 15px;
    }

    .interval_cont {
        display: flex;
        justify-content: space-around;
        width: auto;
        overflow: hidden;
    }

    .interval_cont:nth-child(n+1):not(:last-child) {
        margin-right: 0.15em;
    }

    .description {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 0.5em;
        margin-right: 0.55em;
        font-size: 0.29em;
        font-weight: bold;
        text-transform: uppercase;
        color: #00437a;
        text-shadow: 0.05em 0.05em 0.1em rgba(136, 110, 87, 0.3);
        overflow: hidden;
    }

    .digit_cont {
        position: relative;
        width: 1.2em;
        height: 1.5em;
        font-weight: 900;
        line-height: 1.5em;
        border-radius: 0.25em;
        color: #00437a;
        border-bottom: 0.01em solid rgba(76, 99, 119, 0.1);
        box-shadow: 0 0.2em 0.3em -0.1em rgba(76, 99, 119, 0.1);
        -webkit-perspective: 3em;
        perspective: 3em;
        box-sizing: border-box;
        overflow: hidden;
    }

    .digit_cont:after {
        content: "";
        position: absolute;
        top: 50%;
        width: 100%;
        height: 0.015em;
        background: rgba(141, 163, 182, 0.25);
        box-shadow: 0 0.01em 0.02em 0 rgba(255, 255, 255, 0.1);
        z-index: 1;
    }

    .digit_cont:nth-child(n+1):not(:last-child) {
        margin-right: 0.05em;
    }

    .digit_cont span {
        display: flex;
        justify-content: center;
        align-items: center;
        position: absolute;
        bottom: 50%;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    .digit_cont .last_placeholder,
    .digit_cont .new_placeholder,
    .digit_cont .last_rotate,
    .digit_cont .new_rotate {
        position: absolute;
        left: 0;
        width: 100%;
        height: 50%;
        text-align: center;
        overflow: hidden;
        box-sizing: border-box;
    }

    .digit_cont .last_placeholder {
        bottom: 0;
        border-radius: 0 0 0.25em 0.25em;
        background: linear-gradient(to bottom, #D2A06B -90%, #D2A06B 100%), #D2A06B;
    }

    .digit_cont .new_placeholder {
        box-shadow: inset 0 0.01em 0 0 rgba(255, 255, 255, 0.5);
    }

    .digit_cont .new_placeholder,
    .digit_cont .last_rotate,
    .digit_cont .new_rotate {
        top: 0;
        border-radius: 0.25em 0.25em 0 0;
        background: linear-gradient(to bottom, transparent 10%, #fff 200%), transparent;
    }

    .digit_cont .last_rotate {
        -webkit-transform-origin: 100% 100%;
        transform-origin: 100% 100%;
        -webkit-animation: last_rotate 0.5s linear forwards;
        animation: last_rotate 0.5s linear forwards;
    }

    .digit_cont .new_rotate {
        border-top: 0.01em solid rgba(76, 99, 119, 0.3);
        background: linear-gradient(to top, #D2A06B -90%, #D2A06B 100%), #D2A06B;
        -webkit-transform-origin: 100% 100%;
        transform-origin: 100% 100%;
        -webkit-animation: new_rotate 0.5s linear forwards;
        animation: new_rotate 0.5s linear forwards;
    }

    .digit_cont .new_rotate .rotated {
        width: 100%;
        height: 100%;
        border-radius: 0 0 0.25em 0.25em;
        -webkit-transform: rotateX(180deg);
        transform: rotateX(180deg);
        overflow: hidden;
        background-color: #D2A06B;
    }

    @media only screen and (max-width: 600px) {
        .flip-countdown {
            font-size: 2.5em;
            /* Adjust font size for smaller screens */
        }

        .interval_cont {
            flex-direction: column;
            /* Stack intervals vertically on smaller screens */
            align-items: center;
            /* Center intervals */
            margin-bottom: 0.5em;
            /* Add some space between intervals */
        }

        .digit_cont {
            width: 1.5em;
            /* Adjust digit container width */
            height: 2em;
            /* Adjust digit container height */
            font-size: 0.8em;
            /* Adjust font size for digits */
        }

        .description {
            margin-top: 0.2em;
            /* Adjust margin for descriptions */
            font-size: 0.2em;
            /* Adjust font size for descriptions */
        }
    }
</style>

<script>
    // == Settings ==
    const lang = 'EN'; // RU or EN description
    const typeCountdown = 'date'; // 'time' to set the countdown to a specific time or 'date' to set the countdown to the designated date

    let EndDate = '2024-5-19 19:30:00'; // Expiration Date yyyy/mm/dd, hh:mm. Working only if typeCountdown = 'date'

    // let days = 9; // Number of days before the end. Working only if typeCountdown = 'time'
    let timeOut = '00:00'; // 'hh:mm'. Number of hours and minutes before the end. Working only if typeCountdown = 'time'

    const ColorDigitEnd = '#bfbfbf';
    // == Settings END ==

    let hours, minutes, target_date, ExpirationDate;
    let formatCountdown = null;
    let day_lang = hour_lang = minute_lang = second_lang = '';


    function daysLeft(target) {
        if (target > (24 * 60 * 60 * 1000)) { formatCountdown = 'day|hour|minute|second'; }
        else if (target > (60 * 60 * 1000)) { formatCountdown = 'hour|minute|second'; }
        else { formatCountdown = 'minute|second'; }
    }

    if (typeCountdown === 'time') {
        timeOut = timeOut.split(':');
        hours = timeOut[0];
        minutes = timeOut[1];
        target_date = ((days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60) * 1000);

        daysLeft(target_date);
        target_date += new Date().getTime();
    } else if (typeCountdown === 'date') {
        ExpirationDate = new Date(EndDate);
        target_date = (ExpirationDate - new Date());
        daysLeft(target_date);
        target_date += new Date().getTime();
    }
    else {
        target_date = 0;
        formatCountdown = 'day|hour|minute|second';
    }

    if (lang === 'RU') {
        day_lang = 'Дней';
        hour_lang = 'Часов';
        minute_lang = 'Минут';
        second_lang = 'Секунд';
    } else if (lang === 'EN') {
        day_lang = 'Days';
        hour_lang = 'Hrs';
        minute_lang = 'Min';
        second_lang = 'Sec';
    }

    class Countdown {
        get TIMESTAMP_SECOND() { return 1000; }
        get TIMESTAMP_MINUTE() { return 60 * this.TIMESTAMP_SECOND; }
        get TIMESTAMP_HOUR() { return 60 * this.TIMESTAMP_MINUTE; }
        get TIMESTAMP_DAY() { return 24 * this.TIMESTAMP_HOUR; }

        constructor(userOptions) {
            this.options = {
                cont: null,
                countdown: true,
                endDate: {
                    day: 0,
                    hour: 0,
                    minute: 0,
                    second: 0
                },
                endCallback: null,
                outputFormat: formatCountdown,
                outputTranslation: {
                    day: day_lang,
                    hour: hour_lang,
                    minute: minute_lang,
                    second: second_lang
                }
            };

            this.lastTick = null;
            this.intervalsBySize = ['day', 'hour', 'minute', 'second'];
            this.interval = null;
            this.digitConts = {};
            this._assignOptions(this.options, userOptions);
        }

        start() {
            let endDate, endDateData;
            this._fixCompatibility();

            endDate = this._getDate(this.options.endDate);
            endDateData = this._prepareTimeByOutputFormat(endDate);

            this._writeData(endDateData);
            this.lastTick = endDateData;

            if (this.options.countdown && endDate.getTime() <= Date.now()) {
                if (typeof this.options.endCallback === 'function') {
                    this.stop();
                    this.options.endCallback();
                }
            } else {
                this.interval = setInterval(() => { this._updateView(this._prepareTimeByOutputFormat(endDate)); },
                    this.TIMESTAMP_SECOND);
            }
        }

        stop() { if (this.interval !== null) { clearInterval(this.interval); } }

        _getDate(date) {
            if (typeof date === 'object') {
                if (date instanceof Date) { return date; }
                else {
                    let expectedValues = {
                        day: 0,
                        hour: 0,
                        minute: 0,
                        second: 0
                    };

                    for (let i in expectedValues) {
                        if (expectedValues.hasOwnProperty(i) && date.hasOwnProperty(i)) { expectedValues[i] = date[i]; }
                    }
                    return new Date(expectedValues.day, expectedValues.hour, expectedValues.minute, expectedValues.second);
                }
            } else if (typeof date === 'number' || typeof date === 'string') { return new Date(date); }
            else { return new Date(); }
        }

        _prepareTimeByOutputFormat(dateObj) {
            let usedIntervals, output = {}, timeDiff;

            usedIntervals = this.intervalsBySize.filter(item => { return this.options.outputFormat.split('|').indexOf(item) !== -1; });

            timeDiff = this.options.countdown ? dateObj.getTime() - Date.now() : Date.now() - dateObj.getTime();

            usedIntervals.forEach(item => {
                let value;
                if (timeDiff > 0) {
                    switch (item) {
                        case 'day':
                            value = Math.trunc(timeDiff / this.TIMESTAMP_DAY);
                            timeDiff -= value * this.TIMESTAMP_DAY;
                            break;
                        case 'hour':
                            value = Math.trunc(timeDiff / this.TIMESTAMP_HOUR);
                            timeDiff -= value * this.TIMESTAMP_HOUR;
                            break;
                        case 'minute':
                            value = Math.trunc(timeDiff / this.TIMESTAMP_MINUTE);
                            timeDiff -= value * this.TIMESTAMP_MINUTE;
                            break;
                        case 'second':
                            value = Math.trunc(timeDiff / this.TIMESTAMP_SECOND);
                            timeDiff -= value * this.TIMESTAMP_SECOND;
                            break;
                    }
                } else {
                    value = '00';
                    const elements = document.querySelectorAll('.digit_cont');
                    for (let i = 0; i < elements.length; i++) { elements[i].style.color = ColorDigitEnd; }
                }
                output[item] = (('' + value).length < 2 ? '0' + value : '' + value).split('');
            });
            return output;
        }

        _fixCompatibility() {
            Math.trunc = Math.trunc || function (x) {
                if (isNaN(x)) { return NaN; }
                if (x > 0) { return Math.floor(x); }
                return Math.ceil(x);
            };
        }

        _writeData(data) {
            let code = ``, intervalName;

            for (intervalName in data) {
                if (data.hasOwnProperty(intervalName)) {
                    let element = `<div><div class="interval_cont interval_cont_${intervalName}">`,
                        intervalDescription = `<div class="description"> ${this.options.outputTranslation[intervalName]}</div>`;

                    data[intervalName].forEach((digit, index) => { element += `<div class="digit_cont digit_cont_${index}" id="test">${this._getDigitElementString(digit, 0)}</div>`; });

                    code += element + '</div>' + intervalDescription + '</div>';
                }
            }
            this.options.cont.innerHTML = code;
            this.lastTick = data;
        }

        _getDigitElementString(newDigit, lastDigit) {
            return `<div class="last_placeholder"><span>${lastDigit}</span></div>
						<div class="new_placeholder">${newDigit}</div>
						<div class="last_rotate">${lastDigit}</div>
						<div class="new_rotate">
							<div class="rotated"><span>${newDigit}</span></div>
						</div>`;
        }

        _updateView(data) {
            for (let intervalName in data) {
                if (data.hasOwnProperty(intervalName)) {
                    data[intervalName].forEach((digit, index) => {
                        if (this.lastTick !== null
                            && this.lastTick[intervalName][index]
                            !== data[intervalName][index]) {
                            this._getDigitCont(intervalName, index).innerHTML = this._getDigitElementString(data[intervalName][index], this.lastTick[intervalName][index]);
                        }
                    });
                }
            }
            this.lastTick = data;
        }

        _getDigitCont(intervalName, index) {
            if (!this.digitConts[`${intervalName}_${index}`]) {
                this.digitConts[`${intervalName}_${index}`] = this.options.cont.querySelector(`.interval_cont_${intervalName} .digit_cont_${index}`);
            }
            return this.digitConts[`${intervalName}_${index}`];
        }

        _assignOptions(options, userOptions) {
            for (let i in options) {
                if (options.hasOwnProperty(i) && userOptions.hasOwnProperty(i)) {
                    if (options[i] !== null && typeof options[i] === 'object' && typeof userOptions[i] === 'object') {
                        this._assignOptions(options[i], userOptions[i]);
                    }
                    else { options[i] = userOptions[i]; }
                }
            }
        }
    }

    let cd = new Countdown({
        cont: document.querySelector('.flip-countdown'),
        endDate: target_date,
        outputTranslation: {
            day: day_lang,
            hour: hour_lang,
            minute: minute_lang,
            second: second_lang
        },

        endCallback: null,
        outputFormat: formatCountdown
    });
    cd.start();

</script>